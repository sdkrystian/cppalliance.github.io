<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://cppalliance.org/feed.xml" rel="self" type="application/atom+xml" /><link href="http://cppalliance.org/" rel="alternate" type="text/html" /><updated>2020-01-31T03:42:06+00:00</updated><id>http://cppalliance.org/feed.xml</id><title type="html">The C++ Alliance</title><subtitle>The C++ Alliance is dedicated to helping the C++ programming language evolve. We see it developing as an ecosystem of open source libraries and as a growing community of those who contribute to those libraries..</subtitle><entry><title type="html">Gold sponsor of C++Now 2020</title><link href="http://cppalliance.org/company/2020/01/30/Gold-sponsor-of-C++-now.html" rel="alternate" type="text/html" title="Gold sponsor of C++Now 2020" /><published>2020-01-30T00:00:00+00:00</published><updated>2020-01-30T00:00:00+00:00</updated><id>http://cppalliance.org/company/2020/01/30/Gold-sponsor-of-C++-now</id><content type="html" xml:base="http://cppalliance.org/company/2020/01/30/Gold-sponsor-of-C++-now.html">&lt;p&gt;The Alliance is a Gold sponsor for
&lt;a href=&quot;http:http://cppnow.org/about/corporate_sponsors/&quot;&gt;C++Now 2020&lt;/a&gt;. This
conference is a gathering of C++ experts and enthusiasts from around
the world in beautiful Aspen, Colorado from May 3, 2020 - May 8, 2020.&lt;/p&gt;</content><author><name></name></author><summary type="html">The Alliance is a Gold sponsor for C++Now 2020. This conference is a gathering of C++ experts and enthusiasts from around the world in beautiful Aspen, Colorado from May 3, 2020 - May 8, 2020.</summary></entry><entry><title type="html">Marshall’s Combined August and September Update</title><link href="http://cppalliance.org/marshall/2019/09/27/MarshallsOctoberUpdate.html" rel="alternate" type="text/html" title="Marshall's Combined August and September Update" /><published>2019-09-27T00:00:00+00:00</published><updated>2019-09-27T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/09/27/MarshallsOctoberUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/09/27/MarshallsOctoberUpdate.html">&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lots of work these month(s) behind the scenes, getting stuff ready for C++20, LLVM 9, and Boost 1.71.0.&lt;/p&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The &lt;a href=&quot;http://releases.llvm.org/download.html#9.0.0&quot;&gt;LLVM 9.0 release&lt;/a&gt; has shipped!  The release date was 19-September, a few days later than planned. There are a lot of new &lt;a href=&quot;http://releases.llvm.org/9.0.0/projects/libcxx/docs/ReleaseNotes.html&quot;&gt;libc++ features&lt;/a&gt; in the release.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;p&gt;Many times, bug reports are based on misunderstandings, but require a couple of hours of work in order to figure out where the misunderstanding lies.&lt;/p&gt;

&lt;p&gt;We’re working on a major redesign of the “debug mode” for libc++, after we realized that the existing (not widely used) debug mode is useless when you’re trying to do things at compile (constexpr) time.&lt;/p&gt;

&lt;p&gt;I have been spending a lot of time the last few weeks working on the calendaring stuff in &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt;, specifically the interface with the OS for getting time zone information. It is a surprisingly complicated task. Fortunately for me, I have a friend who has been down this road in the past, and is willing to answer questions.&lt;/p&gt;

&lt;h3 id=&quot;lwg-issues-resolved-in-libc-almost-certainly-incomplete&quot;&gt;LWG issues resolved in libc++ (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/LWG3296&quot;&gt;LWG3296&lt;/a&gt;	Add a missing default parameter to &lt;code class=&quot;highlighter-rouge&quot;&gt;regex::assign&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-features-implemented-almost-certainly-incomplete&quot;&gt;LLVM features implemented (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1466&quot;&gt;P1466&lt;/a&gt;	Parts of P1466 “Misc Chrono fixes” more to come here.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-definitely-incomplete&quot;&gt;LLVM bugs resolved (definitely incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/PR42918&quot;&gt;Bug 42918&lt;/a&gt;	Fix thread comparison by making sure we never pass our special ‘not a thread’ value to the underlying implementation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/PR43063&quot;&gt;Bug 43063&lt;/a&gt;	Fix a couple of unguarded &lt;code class=&quot;highlighter-rouge&quot;&gt;operator,&lt;/code&gt; calls in algorithm&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/PR43034&quot;&gt;Bug 43034&lt;/a&gt;	Add a missing &lt;code class=&quot;highlighter-rouge&quot;&gt;_VSTD::&lt;/code&gt; before a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/PR43300&quot;&gt;Bug 43300&lt;/a&gt;	Add a missing &lt;code class=&quot;highlighter-rouge&quot;&gt;_VSTD::&lt;/code&gt; Only initialize the streams &lt;code class=&quot;highlighter-rouge&quot;&gt;cout&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;wcout&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;cerr&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;wcerr&lt;/code&gt; etc once, rather than any time &lt;code class=&quot;highlighter-rouge&quot;&gt;Init::Init&lt;/code&gt; is called&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;other-interesting-llvm-bits-from-certainly-incomplete&quot;&gt;Other interesting LLVM bits from (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/r368299&quot;&gt;Revision 368299&lt;/a&gt; Implement &lt;code class=&quot;highlighter-rouge&quot;&gt;hh_mm_ss&lt;/code&gt; from &lt;a href=&quot;https://wg21.link/P1466&quot;&gt;P1466&lt;/a&gt;. Part of the ongoing &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;chrono&amp;gt;&lt;/code&gt; implementation work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;We shipped a CD out of Cologne in July. Now we wait for the National Bodies (members of ISO, aka “NBs”) to review the draft and send us comments. When we’ve resolved all of these comments, we will send the revised draft out for balloting. If the NBs approve, then that draft will become C++20.&lt;/p&gt;

&lt;p&gt;The next WG21 meeting will be November 2-8 in Belfast, Northern Ireland.
This will be the first of two meetings that are focused on resolving NB comments; the second one will be in Prague in February.&lt;/p&gt;

&lt;p&gt;I have several “clean-up” papers for the Belfast mailing. The mailing deadline is a week from Monday (5-October), so I need to finish them up.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1718&quot;&gt;P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1719&quot;&gt;P1719R0: Mandating the Standard Library: Clause 26 - Numerics library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1720&quot;&gt;P1720R0: Mandating the Standard Library: Clause 28 - Localization library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1721&quot;&gt;P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1722&quot;&gt;P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1723&quot;&gt;P1723R0: Mandating the Standard Library: Clause 31 - Atomics library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We polled the NBs before Cologne, and they graciously agreed to have these changes made post-CD.&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.boost.org/users/history/version_1_71_0.html&quot;&gt;Boost 1.71.0&lt;/a&gt; was released on 19-August. Micheal Caisse was the release manager, with some help from me.&lt;/p&gt;

&lt;p&gt;As part of the Boost Community maintenance team, I (and others) made many changes to libraries whose authors are no longer able (or interested) in maintaining them.&lt;/p&gt;

&lt;p&gt;I have a couple of suggestions for additions to the Boost.Algorithms library that I will be working on in the near future.&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;I was a speaker at &lt;a href=&quot;https://www.cppcon.com&quot;&gt;CppCon&lt;/a&gt; last week. I gave a new talk “std::midpoint - How hard could it be?” (no link yet) which was quite well received. I got a few questions that will require additional research, and may improve my implementation.&lt;/p&gt;

&lt;p&gt;I also participated in the “Committee Fireside Chat”, at CppCon, where conference members get to ask questions of the committee members who are present.&lt;/p&gt;

&lt;p&gt;Upcoming talks:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://llvm.org/devmtg/2019-10/&quot;&gt;LLVM Developer’s Conference&lt;/a&gt; is in San Jose in October. I will not be speaking, but I will be moderating the lightning talks.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cppconf-piter.ru/en/&quot;&gt;C++ Russia&lt;/a&gt; is at the end of October in St. Petersburg.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://conference.accu.org&quot;&gt;ACCU Autumn&lt;/a&gt; is right after the WG21 meeting in early November.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://meetingcpp.com&quot;&gt;Meeting C++&lt;/a&gt; is in mid-November in Berlin.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will be making the “Fall 2019 C++ European Tour”, going from St. Petersburg to Belfast to Berlin before heading home mid-November.&lt;/p&gt;</content><author><name></name></author><summary type="html">There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences Lots of work these month(s) behind the scenes, getting stuff ready for C++20, LLVM 9, and Boost 1.71.0. Libc++ The LLVM 9.0 release has shipped! The release date was 19-September, a few days later than planned. There are a lot of new libc++ features in the release. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. Many times, bug reports are based on misunderstandings, but require a couple of hours of work in order to figure out where the misunderstanding lies. We’re working on a major redesign of the “debug mode” for libc++, after we realized that the existing (not widely used) debug mode is useless when you’re trying to do things at compile (constexpr) time. I have been spending a lot of time the last few weeks working on the calendaring stuff in &amp;lt;chrono&amp;gt;, specifically the interface with the OS for getting time zone information. It is a surprisingly complicated task. Fortunately for me, I have a friend who has been down this road in the past, and is willing to answer questions. LWG issues resolved in libc++ (almost certainly incomplete) LWG3296 Add a missing default parameter to regex::assign LLVM features implemented (almost certainly incomplete) P1466 Parts of P1466 “Misc Chrono fixes” more to come here. LLVM bugs resolved (definitely incomplete) Bug 42918 Fix thread comparison by making sure we never pass our special ‘not a thread’ value to the underlying implementation Bug 43063 Fix a couple of unguarded operator, calls in algorithm Bug 43034 Add a missing _VSTD:: before a call to merge. Bug 43300 Add a missing _VSTD:: Only initialize the streams cout/wcout/cerr/wcerr etc once, rather than any time Init::Init is called Other interesting LLVM bits from (certainly incomplete) Revision 368299 Implement hh_mm_ss from P1466. Part of the ongoing &amp;lt;chrono&amp;gt; implementation work. The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 We shipped a CD out of Cologne in July. Now we wait for the National Bodies (members of ISO, aka “NBs”) to review the draft and send us comments. When we’ve resolved all of these comments, we will send the revised draft out for balloting. If the NBs approve, then that draft will become C++20. The next WG21 meeting will be November 2-8 in Belfast, Northern Ireland. This will be the first of two meetings that are focused on resolving NB comments; the second one will be in Prague in February. I have several “clean-up” papers for the Belfast mailing. The mailing deadline is a week from Monday (5-October), so I need to finish them up. P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library P1719R0: Mandating the Standard Library: Clause 26 - Numerics library P1720R0: Mandating the Standard Library: Clause 28 - Localization library P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library P1723R0: Mandating the Standard Library: Clause 31 - Atomics library We polled the NBs before Cologne, and they graciously agreed to have these changes made post-CD. Boost Boost 1.71.0 was released on 19-August. Micheal Caisse was the release manager, with some help from me. As part of the Boost Community maintenance team, I (and others) made many changes to libraries whose authors are no longer able (or interested) in maintaining them. I have a couple of suggestions for additions to the Boost.Algorithms library that I will be working on in the near future. Conferences I was a speaker at CppCon last week. I gave a new talk “std::midpoint - How hard could it be?” (no link yet) which was quite well received. I got a few questions that will require additional research, and may improve my implementation. I also participated in the “Committee Fireside Chat”, at CppCon, where conference members get to ask questions of the committee members who are present. Upcoming talks: LLVM Developer’s Conference is in San Jose in October. I will not be speaking, but I will be moderating the lightning talks. C++ Russia is at the end of October in St. Petersburg. ACCU Autumn is right after the WG21 meeting in early November. Meeting C++ is in mid-November in Berlin. I will be making the “Fall 2019 C++ European Tour”, going from St. Petersburg to Belfast to Berlin before heading home mid-November.</summary></entry><entry><title type="html">Gold Sponsor Of Cppcon 2019</title><link href="http://cppalliance.org/company/2019/09/01/Gold-sponsor-of-Cppcon-2019.html" rel="alternate" type="text/html" title="Gold Sponsor Of Cppcon 2019" /><published>2019-09-01T00:00:00+00:00</published><updated>2019-09-01T00:00:00+00:00</updated><id>http://cppalliance.org/company/2019/09/01/Gold-sponsor-of-Cppcon-2019</id><content type="html" xml:base="http://cppalliance.org/company/2019/09/01/Gold-sponsor-of-Cppcon-2019.html">&lt;p&gt;
The Alliance is a Gold sponsor for
&lt;a href=&quot;https://cppcon.org/history/2019/&quot;&gt;CppCon 2019&lt;/a&gt;. This
conference is the annual, week-long face-to-face gathering for the
entire C++ community. The conference is organized by the C++ community
for the community. Attendees enjoy inspirational talks and a friendly
atmosphere designed to help individuals learn from each other, meet
interesting people, and generally have a stimulating experience.
&lt;/p&gt;</content><author><name></name></author><summary type="html">The Alliance is a Gold sponsor for CppCon 2019. This conference is the annual, week-long face-to-face gathering for the entire C++ community. The conference is organized by the C++ community for the community. Attendees enjoy inspirational talks and a friendly atmosphere designed to help individuals learn from each other, meet interesting people, and generally have a stimulating experience.</summary></entry><entry><title type="html">Damian’s July Update</title><link href="http://cppalliance.org/company,/damian/2019/08/19/DamiansAugustUpdate.html" rel="alternate" type="text/html" title="Damian's July Update" /><published>2019-08-19T00:00:00+00:00</published><updated>2019-08-19T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/08/19/DamiansAugustUpdate</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/08/19/DamiansAugustUpdate.html">&lt;h1 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h1&gt;

&lt;p&gt;I’ve started working on improvements to the zlib part of Beast. There are some gaps
in the test harness of these components, so I’ve decided to increase coverage.
As a first step, I started porting test cases from the original zlib library’s tests,
to verify that existing code matches the expected behavior of the original library.
Fortunately, I’ve not found any significant discrepancies, there’s only one issue
where Beast rejects malformed input for the wrong reason (I’m still looking into it
whether it’s actually an issue at the time of writing this).&lt;/p&gt;

&lt;p&gt;I’ve also looked into providing more meaningful feedback from test failures in Beast,
especially when they’re run in CI. While the current test framework does print
a line number on failure, the line number is often in a function template that’s called
by multiple test cases, which makes it quite hard to determine which test failed
just from the log, often requiring the use of a debugger. Doing that locally
may not be a problem, but it’s significantly harder in CI, so I’ve decided to
try to use Boost Stacktrace to provide a callstack on each failure in Beast tests.
Additionally, I’ve also worked on running the test suite without OpenSSL installed,
to hopefully fix some of the failures in the official Boost test matrix.&lt;/p&gt;

&lt;h1 id=&quot;the-question-of-networking-ts-and-tls&quot;&gt;The question of Networking TS and TLS&lt;/h1&gt;

&lt;p&gt;There’s recently been quite a bit of discussion of networking being useless
without “secure by default” sockets. Since this is a recurring topic and I expect it to return in the future,
so I’ve decided to write up an analysis of this issue.&lt;/p&gt;

&lt;p&gt;First of all, I believe that an attempt to deliver a “secure by default” socket
within the current networking proposal right now will result in something like
&lt;code class=&quot;highlighter-rouge&quot;&gt;std::async&lt;/code&gt; - not really practically useful.&lt;/p&gt;

&lt;p&gt;What kind of TLS facilities I’d consider useful for the average user of the standard library?
A reasonable guideline, I think, are ones I could trust to be used in a distributed
system that handles money (in any form).
Note, that TLS is not only a protocol that provides confidentiality (i.e. encryption),
but also allows verification of the identity either the server by the client, or both.
Remember, doesn’t matter if 3rd parties can’t see what you’re sending,
if you’re sending your data to the wrong peer in the first place!&lt;/p&gt;

&lt;p&gt;While it may seem simple at first look, just verifying the identity of a peer
is an extremely complex process, as my experience with Certify has shown.
Doing it portably and efficiently with the same interface and effects is extremely difficult.
Browsers resort to all kinds of workarounds and custom solutions to be able
to securely implement just this one aspect of TLS. I attempted to implement
a library (intended for inclusion into Boost) that would perform this one aspect,
however, I found it to be impossible to provide a practical solution with
the current state of the networking ecosystem in Boost. In fact, one method
of certificate verification (via the OCSP protocol) requires a (very) basic
HTTP client. Yes, in order to perform a TLS handshake and verify the peer’s
certificate status using OCSP, you need an HTTP client.&lt;/p&gt;

&lt;p&gt;This is just one aspect of the TLS protocol that needs to be addressed.
There are others as well - what about the basic cryptographic building blocks,
like ciphers, hashing algorithms, PRFs and so on - they are bound to be used
in a hypothetical implementation in a standard library, should they be exposed? If yes then with what interface?.
Considering that there are no standard networking facilities and not even a proposal for standard TLS,
this is a discussion that would essentially postpone standard networking indefinitely.&lt;/p&gt;

&lt;p&gt;Finally, there’s also an opposite position that no networking should be
in the standard at all. I disagree with this position - networking has become a very important
part of many C++ projects (in my career, all C++ projects I dealt with, touched
some sort of network in one way or another).
At the very least we need standard named requirements for library compatibility, since that is
severely lacking in the ecosystem at this point.&lt;/p&gt;</content><author><name></name></author><summary type="html">Boost.Beast I’ve started working on improvements to the zlib part of Beast. There are some gaps in the test harness of these components, so I’ve decided to increase coverage. As a first step, I started porting test cases from the original zlib library’s tests, to verify that existing code matches the expected behavior of the original library. Fortunately, I’ve not found any significant discrepancies, there’s only one issue where Beast rejects malformed input for the wrong reason (I’m still looking into it whether it’s actually an issue at the time of writing this). I’ve also looked into providing more meaningful feedback from test failures in Beast, especially when they’re run in CI. While the current test framework does print a line number on failure, the line number is often in a function template that’s called by multiple test cases, which makes it quite hard to determine which test failed just from the log, often requiring the use of a debugger. Doing that locally may not be a problem, but it’s significantly harder in CI, so I’ve decided to try to use Boost Stacktrace to provide a callstack on each failure in Beast tests. Additionally, I’ve also worked on running the test suite without OpenSSL installed, to hopefully fix some of the failures in the official Boost test matrix. The question of Networking TS and TLS There’s recently been quite a bit of discussion of networking being useless without “secure by default” sockets. Since this is a recurring topic and I expect it to return in the future, so I’ve decided to write up an analysis of this issue. First of all, I believe that an attempt to deliver a “secure by default” socket within the current networking proposal right now will result in something like std::async - not really practically useful. What kind of TLS facilities I’d consider useful for the average user of the standard library? A reasonable guideline, I think, are ones I could trust to be used in a distributed system that handles money (in any form). Note, that TLS is not only a protocol that provides confidentiality (i.e. encryption), but also allows verification of the identity either the server by the client, or both. Remember, doesn’t matter if 3rd parties can’t see what you’re sending, if you’re sending your data to the wrong peer in the first place! While it may seem simple at first look, just verifying the identity of a peer is an extremely complex process, as my experience with Certify has shown. Doing it portably and efficiently with the same interface and effects is extremely difficult. Browsers resort to all kinds of workarounds and custom solutions to be able to securely implement just this one aspect of TLS. I attempted to implement a library (intended for inclusion into Boost) that would perform this one aspect, however, I found it to be impossible to provide a practical solution with the current state of the networking ecosystem in Boost. In fact, one method of certificate verification (via the OCSP protocol) requires a (very) basic HTTP client. Yes, in order to perform a TLS handshake and verify the peer’s certificate status using OCSP, you need an HTTP client. This is just one aspect of the TLS protocol that needs to be addressed. There are others as well - what about the basic cryptographic building blocks, like ciphers, hashing algorithms, PRFs and so on - they are bound to be used in a hypothetical implementation in a standard library, should they be exposed? If yes then with what interface?. Considering that there are no standard networking facilities and not even a proposal for standard TLS, this is a discussion that would essentially postpone standard networking indefinitely. Finally, there’s also an opposite position that no networking should be in the standard at all. I disagree with this position - networking has become a very important part of many C++ projects (in my career, all C++ projects I dealt with, touched some sort of network in one way or another). At the very least we need standard named requirements for library compatibility, since that is severely lacking in the ecosystem at this point.</summary></entry><entry><title type="html">Marshall’s July Update</title><link href="http://cppalliance.org/marshall/2019/08/05/MarshallsAugustUpdate.html" rel="alternate" type="text/html" title="Marshall's July Update" /><published>2019-08-05T00:00:00+00:00</published><updated>2019-08-05T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/08/05/MarshallsAugustUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/08/05/MarshallsAugustUpdate.html">&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This month, the big news (and the big work item) was the approval of the C++ “Committee Draft” at the WG21 meeting in Cologne on July 15-20.&lt;/p&gt;

&lt;p&gt;You can think of this as a “beta version” of the C++20 standard; all features are complete. The next step is bug fixing, with an eye towards releasing next year.&lt;/p&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The LLVM 9.0 release is on track for September. We have a release branch, and the RC1 was recently dropped.&lt;/p&gt;

&lt;p&gt;Because of the run-up and the aftermath of the Cologne meeting, the libc++ accomplishments are a bit sparse this month.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;h3 id=&quot;lwg-issues-resolved-this-month-in-libc-almost-certainly-incomplete&quot;&gt;LWG issues resolved this month in libc++ (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/LWG2273&quot;&gt;LWG2273&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;regex_match&lt;/code&gt; ambiguity&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-features-implemented-this-month-almost-certainly-incomplete&quot;&gt;LLVM features implemented this month (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1612&quot;&gt;P1612&lt;/a&gt;	Relocate endian&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1466&quot;&gt;P1466&lt;/a&gt;	Parts of P1466 “Misc Chrono fixes” more to come here.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-this-month-definitely-incomplete&quot;&gt;LLVM bugs resolved this month (definitely incomplete)&lt;/h3&gt;

&lt;!-- 
* [Bug 36863](https://llvm.org/PR36863)	`basic_string_view(const CharT*, size_type)` constructor shouldn't comment out assert of nullptr and length checks
* [Bug 42166](https://llvm.org/PR42166)	`to_chars` can puts leading zeros on numbers
 --&gt;

&lt;h3 id=&quot;other-interesting-llvm-bits-from-this-month-certainly-incomplete&quot;&gt;Other interesting LLVM bits from this month (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/r365854&quot;&gt;Revision 365854&lt;/a&gt; Reorganize the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; header to make most of the facilities available for internal use pre-C++20. NFC for external users.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/r367120&quot;&gt;Revision 367120&lt;/a&gt; Fix a bug in std::chrono::abs where it would fail when the duration’s period had not been reduced.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/r364884&quot;&gt;Revision 364884&lt;/a&gt; Add an internal call &lt;code class=&quot;highlighter-rouge&quot;&gt;__libcpp_is_constant_evaluated&lt;/code&gt;, which works like &lt;code class=&quot;highlighter-rouge&quot;&gt;std::is_constant_evaluated&lt;/code&gt;, except that it can be called at any language level (back to C++98). For older languages, it just returns &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. This gets rid of a lot of ifdefs in the libc++ source code.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;As I said above, we shipped a CD out of Cologne. Now we wait for the National Bodies (members of ISO, aka “NBs”) to review the draft and send us comments. When we’ve resolved all of these comments, we will send the revised draft out for balloting. If the NBs approve, then that draft will become C++20.&lt;/p&gt;

&lt;p&gt;We approved many new features for C++20 in Cologne:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0553&quot;&gt;P0553&lt;/a&gt; - Bit Operations&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0980&quot;&gt;P0980&lt;/a&gt; - Constexpr &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1004&quot;&gt;P1004&lt;/a&gt; - Constexpr &lt;code class=&quot;highlighter-rouge&quot;&gt;vector&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1065&quot;&gt;P1065&lt;/a&gt; - Constexpr &lt;code class=&quot;highlighter-rouge&quot;&gt;INVOKE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1135&quot;&gt;P1135&lt;/a&gt; - The C++20 Synchronization Library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1208&quot;&gt;P1208&lt;/a&gt; - Source Location&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0645&quot;&gt;P0645&lt;/a&gt; - Text Formatting&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1361&quot;&gt;P1361&lt;/a&gt; - Integration of &lt;code class=&quot;highlighter-rouge&quot;&gt;chrono&lt;/code&gt; with text formatting&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1754&quot;&gt;P1754&lt;/a&gt; - Rename concepts to standard_case for C++20, while we still can&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1614&quot;&gt;P1614&lt;/a&gt; - Spaceship integration in the Standard Library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0600&quot;&gt;P0600&lt;/a&gt; - Stop Tokens and a Joining Thread&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0631&quot;&gt;P0631&lt;/a&gt; - Math Constants&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We also did not approve many proposed features. Most of these were not approved because we ran out of time, rather than any fault of theirs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1391&quot;&gt;P1391&lt;/a&gt; - Range constructors for &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1394&quot;&gt;P1394&lt;/a&gt; - Range constructors for &lt;code class=&quot;highlighter-rouge&quot;&gt;span&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0288&quot;&gt;P0288&lt;/a&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;any_invokable&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0201&quot;&gt;P0201&lt;/a&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;polymorphic_value&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0429&quot;&gt;P0429&lt;/a&gt; - A Standard flatmap&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1222&quot;&gt;P1222&lt;/a&gt; - A Standard flatset&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0533&quot;&gt;P0533&lt;/a&gt; - constexpr for cmath&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0792&quot;&gt;P0792&lt;/a&gt; - &lt;code class=&quot;highlighter-rouge&quot;&gt;function_ref&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0881&quot;&gt;P0881&lt;/a&gt; - A Proposal to add stacktrace library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/1272&quot;&gt;P1272&lt;/a&gt; - Byte-swapping&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/0627&quot;&gt;P0627&lt;/a&gt; - Function to mark unreachable code&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;and many others&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I still have a bunch of mechanical changes that need to be made before we ship:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1718&quot;&gt;P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1719&quot;&gt;P1719R0: Mandating the Standard Library: Clause 26 - Numerics library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1720&quot;&gt;P1720R0: Mandating the Standard Library: Clause 28 - Localization library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1721&quot;&gt;P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1722&quot;&gt;P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1723&quot;&gt;P1723R0: Mandating the Standard Library: Clause 31 - Atomics library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We polled the NBs before Cologne, and they graciously agreed to have these changes made post-CD.&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;The next &lt;a href=&quot;https://www.boost.org/development/index.html&quot;&gt;Boost release cycle&lt;/a&gt; is in process; I am helping Michael Caisse as release manager with this release. We should have a release in the next couple of weeks.&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;Upcoming talks:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cppcon.com&quot;&gt;CppCon&lt;/a&gt; in September in Denver.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cppconf-piter.ru/en/&quot;&gt;C++ Russia&lt;/a&gt; is at the end of October in St. Petersburg.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://conference.accu.org&quot;&gt;ACCU Autumn&lt;/a&gt; is right after the WG21 meeting in early November.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://meetingcpp.com&quot;&gt;Meeting C++&lt;/a&gt; is in mid-November in Berlin.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I will be making the “Fall 2019 C++ European Tour”, going from St. Petersburg to Belfast to Berlin before heading home mid-November.&lt;/p&gt;</content><author><name></name></author><summary type="html">There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences This month, the big news (and the big work item) was the approval of the C++ “Committee Draft” at the WG21 meeting in Cologne on July 15-20. You can think of this as a “beta version” of the C++20 standard; all features are complete. The next step is bug fixing, with an eye towards releasing next year. Libc++ The LLVM 9.0 release is on track for September. We have a release branch, and the RC1 was recently dropped. Because of the run-up and the aftermath of the Cologne meeting, the libc++ accomplishments are a bit sparse this month. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. LWG issues resolved this month in libc++ (almost certainly incomplete) LWG2273 regex_match ambiguity LLVM features implemented this month (almost certainly incomplete) P1612 Relocate endian P1466 Parts of P1466 “Misc Chrono fixes” more to come here. LLVM bugs resolved this month (definitely incomplete) Other interesting LLVM bits from this month (certainly incomplete) Revision 365854 Reorganize the &amp;lt;bit&amp;gt; header to make most of the facilities available for internal use pre-C++20. NFC for external users. Revision 367120 Fix a bug in std::chrono::abs where it would fail when the duration’s period had not been reduced. Revision 364884 Add an internal call __libcpp_is_constant_evaluated, which works like std::is_constant_evaluated, except that it can be called at any language level (back to C++98). For older languages, it just returns false. This gets rid of a lot of ifdefs in the libc++ source code. The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 As I said above, we shipped a CD out of Cologne. Now we wait for the National Bodies (members of ISO, aka “NBs”) to review the draft and send us comments. When we’ve resolved all of these comments, we will send the revised draft out for balloting. If the NBs approve, then that draft will become C++20. We approved many new features for C++20 in Cologne: P0553 - Bit Operations P0980 - Constexpr string P1004 - Constexpr vector P1065 - Constexpr INVOKE P1135 - The C++20 Synchronization Library P1208 - Source Location P0645 - Text Formatting P1361 - Integration of chrono with text formatting P1754 - Rename concepts to standard_case for C++20, while we still can P1614 - Spaceship integration in the Standard Library P0600 - Stop Tokens and a Joining Thread P0631 - Math Constants We also did not approve many proposed features. Most of these were not approved because we ran out of time, rather than any fault of theirs: P1391 - Range constructors for string_view P1394 - Range constructors for span P0288 - any_invokable P0201 - polymorphic_value P0429 - A Standard flatmap P1222 - A Standard flatset P0533 - constexpr for cmath P0792 - function_ref P0881 - A Proposal to add stacktrace library P1272 - Byte-swapping P0627 - Function to mark unreachable code and many others I still have a bunch of mechanical changes that need to be made before we ship: P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library P1719R0: Mandating the Standard Library: Clause 26 - Numerics library P1720R0: Mandating the Standard Library: Clause 28 - Localization library P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library P1723R0: Mandating the Standard Library: Clause 31 - Atomics library We polled the NBs before Cologne, and they graciously agreed to have these changes made post-CD. Boost The next Boost release cycle is in process; I am helping Michael Caisse as release manager with this release. We should have a release in the next couple of weeks. Conferences Upcoming talks: CppCon in September in Denver. C++ Russia is at the end of October in St. Petersburg. ACCU Autumn is right after the WG21 meeting in early November. Meeting C++ is in mid-November in Berlin. I will be making the “Fall 2019 C++ European Tour”, going from St. Petersburg to Belfast to Berlin before heading home mid-November.</summary></entry><entry><title type="html">Damian’s June Update</title><link href="http://cppalliance.org/company,/damian/2019/07/14/DamiansJulyUpdate.html" rel="alternate" type="text/html" title="Damian's June Update" /><published>2019-07-14T00:00:00+00:00</published><updated>2019-07-14T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/07/14/DamiansJulyUpdate</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/07/14/DamiansJulyUpdate.html">&lt;p&gt;This month I’ve been working on the following projects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Certify&lt;/li&gt;
  &lt;li&gt;Boost.Beast&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;certify&quot;&gt;Certify&lt;/h1&gt;
&lt;p&gt;After quite a bit of work exploring ways to make certificate verification more complete,
I’ve concluded that Boost is currently missing a few tools to make that viable.
A comprehensive solution requires, at the very least, a functional HTTP client
able to handle higher-level semantics like redirects, proxies or compressed bodies.
While these are unlikely to happen while performing an OCSP query or downloading
a CRL set from Google’s update service, they still need to be handled, otherwise
the user will be left in a no better state than when no library is used.
At this point, Certify only offers basic verification, but that is still
simillar level to what cURL does. Providing a comprehensive solution will require
either a infrastructure solution (something like Google’s CRLsets) or
a library based one (i.e. build up all the required libraries to be able
to perform proper certificate status checks).&lt;/p&gt;

&lt;h1 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h1&gt;
&lt;p&gt;I’ve continued the work on expanding split compilation in Beast, by turning some
internal function templates, in websocket code, into regular functions. Additionally,
I’ve simplified the websocket prng code after proving with some benchmarks that the
previous solution made it worse both for the fast case (with TLS enabled)
and the slow one. The speed up is marginal, but it made the code much simpler
and reduced the size of binaries by small amount (a few K at best).
I’ve also worked to cleaning up some of the compilation warnings that I found
using the new Azure Piepelines CI in Beast. I also had to deal with an an odd case of
miscompilation under MSVC 14.2 (x64 Release), where the use of &lt;code class=&quot;highlighter-rouge&quot;&gt;static_string&amp;lt;7&amp;gt;&lt;/code&gt;
failed tests with paritally garbage output while &lt;code class=&quot;highlighter-rouge&quot;&gt;static_string&amp;lt;8&amp;gt;&lt;/code&gt; succeeded.&lt;/p&gt;</content><author><name></name></author><summary type="html">This month I’ve been working on the following projects: Certify Boost.Beast Certify After quite a bit of work exploring ways to make certificate verification more complete, I’ve concluded that Boost is currently missing a few tools to make that viable. A comprehensive solution requires, at the very least, a functional HTTP client able to handle higher-level semantics like redirects, proxies or compressed bodies. While these are unlikely to happen while performing an OCSP query or downloading a CRL set from Google’s update service, they still need to be handled, otherwise the user will be left in a no better state than when no library is used. At this point, Certify only offers basic verification, but that is still simillar level to what cURL does. Providing a comprehensive solution will require either a infrastructure solution (something like Google’s CRLsets) or a library based one (i.e. build up all the required libraries to be able to perform proper certificate status checks). Boost.Beast I’ve continued the work on expanding split compilation in Beast, by turning some internal function templates, in websocket code, into regular functions. Additionally, I’ve simplified the websocket prng code after proving with some benchmarks that the previous solution made it worse both for the fast case (with TLS enabled) and the slow one. The speed up is marginal, but it made the code much simpler and reduced the size of binaries by small amount (a few K at best). I’ve also worked to cleaning up some of the compilation warnings that I found using the new Azure Piepelines CI in Beast. I also had to deal with an an odd case of miscompilation under MSVC 14.2 (x64 Release), where the use of static_string&amp;lt;7&amp;gt; failed tests with paritally garbage output while static_string&amp;lt;8&amp;gt; succeeded.</summary></entry><entry><title type="html">Marshall’s June Update</title><link href="http://cppalliance.org/marshall/2019/07/02/MarshallsJulyUpdate.html" rel="alternate" type="text/html" title="Marshall's June Update" /><published>2019-07-02T00:00:00+00:00</published><updated>2019-07-02T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/07/02/MarshallsJulyUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/07/02/MarshallsJulyUpdate.html">&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The next big milestone for libc++ is the LLVM 9.0 release this summer. We’re working towards that, implementing new features and fixing bugs. The “Branch for release” is currently scheduled for July 18th.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;p&gt;I created a &lt;a href=&quot;https://libcxx.llvm.org/upcoming_meeting.html&quot;&gt;status page&lt;/a&gt; for the LWG issues and papers that are already set up for a vote at the Cologne WG21 meeting.&lt;/p&gt;

&lt;h3 id=&quot;lwg-issues-resolved-this-month-in-libc-almost-certainly-incomplete&quot;&gt;LWG issues resolved this month in libc++ (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/LWG2221&quot;&gt;LWG2221&lt;/a&gt;	No formatted output operator for &lt;code class=&quot;highlighter-rouge&quot;&gt;nullptr&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/LWG3206&quot;&gt;LWG3206&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;year_month_day&lt;/code&gt; conversion to &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_days&lt;/code&gt; uses not-existing member function&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-features-implemented-this-month-almost-certainly-incomplete&quot;&gt;LLVM features implemented this month (almost certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P0553&quot;&gt;P0553&lt;/a&gt;	Bit operations&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P0556&quot;&gt;P0556&lt;/a&gt;	Integral power-of-2 operations&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1355&quot;&gt;P1355&lt;/a&gt;	Exposing a narrow contract for &lt;code class=&quot;highlighter-rouge&quot;&gt;ceil2&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P0646&quot;&gt;P0646&lt;/a&gt;	Improving the Return Value of Erase-Like Algorithms I&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-this-month-probably-incomplete&quot;&gt;LLVM bugs resolved this month (probably incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR41843&quot;&gt;Bug 41843&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;std::is_base_of&lt;/code&gt; should give correct result for incomplete unions&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR38638&quot;&gt;Bug 38638&lt;/a&gt;	Wrong constraint for &lt;code class=&quot;highlighter-rouge&quot;&gt;std::optional&amp;lt;T&amp;gt;::operator=(U&amp;amp;&amp;amp;)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR30589&quot;&gt;Bug 30589&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;std::complex&lt;/code&gt; with a custom type does not work because of how std::__promote is defined&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR42396&quot;&gt;Bug 42396&lt;/a&gt;	Alignment not respected in containers for over-aligned enumeration types&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR28704&quot;&gt;Bug 28704&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;num_get::do_get&lt;/code&gt; incorrect digit grouping check&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR18074&quot;&gt;Bug 18074&lt;/a&gt;	Undefined references when using pointer to member functions&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR26503&quot;&gt;Bug 26503&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;std::quoted&lt;/code&gt; doesn’t work with &lt;code class=&quot;highlighter-rouge&quot;&gt;char16_t&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;char32_t&lt;/code&gt; strings.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR41714&quot;&gt;Bug 41714&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;std::tuple&amp;lt;&amp;gt;&lt;/code&gt; is not trivially constructible&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR36863&quot;&gt;Bug 36863&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;basic_string_view(const CharT*, size_type)&lt;/code&gt; constructor shouldn’t comment out assert of nullptr and length checks&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR42166&quot;&gt;Bug 42166&lt;/a&gt;	&lt;code class=&quot;highlighter-rouge&quot;&gt;to_chars&lt;/code&gt; can puts leading zeros on numbers&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;other-llvm-bits-from-this-month-certainly-incomplete&quot;&gt;Other LLVM bits from this month (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://llvm.org/r364545&quot;&gt;Revision 364545&lt;/a&gt;	Provide hashers for &lt;code class=&quot;highlighter-rouge&quot;&gt;string_view&lt;/code&gt; only if they are using the default &lt;code class=&quot;highlighter-rouge&quot;&gt;char_traits&lt;/code&gt;. Reported on &lt;a href=&quot;https://stackoverflow.com/questions/56784597/is-libc-providing-hash-specialization-for-too-many-basic-string-views/56792608#56792608&quot;&gt;StackOverflow&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reworked &lt;code class=&quot;highlighter-rouge&quot;&gt;to_string&lt;/code&gt; to use &lt;code class=&quot;highlighter-rouge&quot;&gt;to_chars&lt;/code&gt;. Much faster, and avoids having multiple implementations. This involved reworking &lt;code class=&quot;highlighter-rouge&quot;&gt;to_chars&lt;/code&gt; so that it was available back to C++03. &lt;em&gt;I did all of the &lt;code class=&quot;highlighter-rouge&quot;&gt;to_chars&lt;/code&gt; refactoring, but not the &lt;code class=&quot;highlighter-rouge&quot;&gt;to_string&lt;/code&gt; rework.&lt;/em&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;The next WG21 meeting is July 15-20 in Cologne, Germany.&lt;/p&gt;

&lt;p&gt;There were no WG21 meetings in June. We (LWG) held four teleconference this month, reviewing papers in advance of the July meeting, and will have another one next week.&lt;/p&gt;

&lt;p&gt;I had seven papers in the pre-Cologne mailing:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1718&quot;&gt;P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1719&quot;&gt;P1719R0: Mandating the Standard Library: Clause 26 - Numerics library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1720&quot;&gt;P1720R0: Mandating the Standard Library: Clause 28 - Localization library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1721&quot;&gt;P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1722&quot;&gt;P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1723&quot;&gt;P1723R0: Mandating the Standard Library: Clause 31 - Atomics library&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/P1724&quot;&gt;P1724R0: C++ Standard Library Issues to be moved in Cologne&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review.&lt;/p&gt;

&lt;p&gt;Also on my TODO list is to attempt to implement some of the proposals that are coming up for a vote in July (&lt;code class=&quot;highlighter-rouge&quot;&gt;flat_map&lt;/code&gt;, text formatting, etc).&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;The next &lt;a href=&quot;https://www.boost.org/development/index.html&quot;&gt;Boost release cycle&lt;/a&gt; is in process; I am helping Michael Caisse as release manager with this release.&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;Upcoming talks:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cppconf-piter.ru/en/&quot;&gt;C++ Russia&lt;/a&gt; is at the end of October in St. Petersburg.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://meetingcpp.com&quot;&gt;Meeting C++&lt;/a&gt; is in mid-November in Berlin.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have submitted a talk for &lt;a href=&quot;https://www.cppcon.com&quot;&gt;CppCon&lt;/a&gt; in September, but I will not hear back about this for a month or two.&lt;/p&gt;

&lt;p&gt;I submitted a talk for &lt;a href=&quot;https://conference.accu.org&quot;&gt;ACCU Autumn&lt;/a&gt;, which is in Belfast right after the WG21 meeting, but I haven’t heard back about that yet. In any case, I will be attending this conference, since it’s in the same hotel as the WG21 meeting, and starts two days after the WG21 meeting, and concludes right before Meeting C++.&lt;/p&gt;</content><author><name></name></author><summary type="html">There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences Libc++ The next big milestone for libc++ is the LLVM 9.0 release this summer. We’re working towards that, implementing new features and fixing bugs. The “Branch for release” is currently scheduled for July 18th. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. I created a status page for the LWG issues and papers that are already set up for a vote at the Cologne WG21 meeting. LWG issues resolved this month in libc++ (almost certainly incomplete) LWG2221 No formatted output operator for nullptr LWG3206 year_month_day conversion to sys_days uses not-existing member function LLVM features implemented this month (almost certainly incomplete) P0553 Bit operations P0556 Integral power-of-2 operations P1355 Exposing a narrow contract for ceil2 P0646 Improving the Return Value of Erase-Like Algorithms I LLVM bugs resolved this month (probably incomplete) Bug 41843 std::is_base_of should give correct result for incomplete unions Bug 38638 Wrong constraint for std::optional&amp;lt;T&amp;gt;::operator=(U&amp;amp;&amp;amp;) Bug 30589 std::complex with a custom type does not work because of how std::__promote is defined Bug 42396 Alignment not respected in containers for over-aligned enumeration types Bug 28704 num_get::do_get incorrect digit grouping check Bug 18074 Undefined references when using pointer to member functions Bug 26503 std::quoted doesn’t work with char16_t or char32_t strings. Bug 41714 std::tuple&amp;lt;&amp;gt; is not trivially constructible Bug 36863 basic_string_view(const CharT*, size_type) constructor shouldn’t comment out assert of nullptr and length checks Bug 42166 to_chars can puts leading zeros on numbers Other LLVM bits from this month (certainly incomplete) Revision 364545 Provide hashers for string_view only if they are using the default char_traits. Reported on StackOverflow Reworked to_string to use to_chars. Much faster, and avoids having multiple implementations. This involved reworking to_chars so that it was available back to C++03. I did all of the to_chars refactoring, but not the to_string rework. The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 The next WG21 meeting is July 15-20 in Cologne, Germany. There were no WG21 meetings in June. We (LWG) held four teleconference this month, reviewing papers in advance of the July meeting, and will have another one next week. I had seven papers in the pre-Cologne mailing: P1718R0: Mandating the Standard Library: Clause 25 - Algorithms library P1719R0: Mandating the Standard Library: Clause 26 - Numerics library P1720R0: Mandating the Standard Library: Clause 28 - Localization library P1721R0: Mandating the Standard Library: Clause 29 - Input/Output library P1722R0: Mandating the Standard Library: Clause 30 - Regular Expression library P1723R0: Mandating the Standard Library: Clause 31 - Atomics library P1724R0: C++ Standard Library Issues to be moved in Cologne The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review. Also on my TODO list is to attempt to implement some of the proposals that are coming up for a vote in July (flat_map, text formatting, etc). Boost The next Boost release cycle is in process; I am helping Michael Caisse as release manager with this release. Conferences Upcoming talks: C++ Russia is at the end of October in St. Petersburg. Meeting C++ is in mid-November in Berlin. I have submitted a talk for CppCon in September, but I will not hear back about this for a month or two. I submitted a talk for ACCU Autumn, which is in Belfast right after the WG21 meeting, but I haven’t heard back about that yet. In any case, I will be attending this conference, since it’s in the same hotel as the WG21 meeting, and starts two days after the WG21 meeting, and concludes right before Meeting C++.</summary></entry><entry><title type="html">Damian’s May Update</title><link href="http://cppalliance.org/company,/damian/2019/06/10/DamiansJuneUpdate.html" rel="alternate" type="text/html" title="Damian's May Update" /><published>2019-06-10T00:00:00+00:00</published><updated>2019-06-10T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/06/10/DamiansJuneUpdate</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/06/10/DamiansJuneUpdate.html">&lt;p&gt;This month I’ve been working on the following projects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Certify&lt;/li&gt;
  &lt;li&gt;Boost.Beast&lt;/li&gt;
  &lt;li&gt;Boost.Build&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;certify&quot;&gt;Certify&lt;/h1&gt;
&lt;p&gt;This month, I’ve worked on expanding the documentation of Certify, especially
the example and introduction parts. When looking through the documentation for
Boost.Build I found out it’s possible to import snippets from *.cpp files
into the documentation, which will allow me to make sure that snippets in
the documentation compile and are tested. I’ve also attempted cleaning up the
Certify build script to use the OpenSSL module in b2, but I ran into issues, so
I’ll have get back to this one in the future.&lt;/p&gt;

&lt;p&gt;Don’t forget to star the repository: &lt;a href=&quot;https://github.com/djarek/certify&quot;&gt;https://github.com/djarek/certify&lt;/a&gt;!&lt;/p&gt;

&lt;h1 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h1&gt;
&lt;p&gt;I’ve been able to complete the port of the Beast CI to Azure Pipelines and expand
the test matrix beyond what was tested in the existing CI infrastructure. Thanks
to the expanded concurrent job limit, a full run on AzP takes less time than a
full Travis and Appveyor build, especially when wait times are taken into accout.
One of the matrix items I added were tests for header-only no-deprecated builds,
which turned out to be broken. Untested code has a nasty tendency to rot.
I’ve also been able to identify some function templates in &lt;code class=&quot;highlighter-rouge&quot;&gt;http::basic_fields&lt;/code&gt;
which could be turned into regular functions. One of them, was instantiated
4 times because they were passed a predicate which was a lambda expression.
These two changes turned out to be fairly significant, because they allowed
shaving off at least 10 KiB of binary size per instantiation (amd64, -O3).&lt;/p&gt;

&lt;h1 id=&quot;boostbuild&quot;&gt;Boost.Build&lt;/h1&gt;
&lt;p&gt;When working on the Azure Pipelines CI for Beast I noticed that b2 doesn’t support
the leak sanitizer, so I decided to add it. It’s available via the &lt;code class=&quot;highlighter-rouge&quot;&gt;leak-sanitizer=on&lt;/code&gt; feature.&lt;/p&gt;</content><author><name></name></author><summary type="html">This month I’ve been working on the following projects: Certify Boost.Beast Boost.Build Certify This month, I’ve worked on expanding the documentation of Certify, especially the example and introduction parts. When looking through the documentation for Boost.Build I found out it’s possible to import snippets from *.cpp files into the documentation, which will allow me to make sure that snippets in the documentation compile and are tested. I’ve also attempted cleaning up the Certify build script to use the OpenSSL module in b2, but I ran into issues, so I’ll have get back to this one in the future. Don’t forget to star the repository: https://github.com/djarek/certify! Boost.Beast I’ve been able to complete the port of the Beast CI to Azure Pipelines and expand the test matrix beyond what was tested in the existing CI infrastructure. Thanks to the expanded concurrent job limit, a full run on AzP takes less time than a full Travis and Appveyor build, especially when wait times are taken into accout. One of the matrix items I added were tests for header-only no-deprecated builds, which turned out to be broken. Untested code has a nasty tendency to rot. I’ve also been able to identify some function templates in http::basic_fields which could be turned into regular functions. One of them, was instantiated 4 times because they were passed a predicate which was a lambda expression. These two changes turned out to be fairly significant, because they allowed shaving off at least 10 KiB of binary size per instantiation (amd64, -O3). Boost.Build When working on the Azure Pipelines CI for Beast I noticed that b2 doesn’t support the leak sanitizer, so I decided to add it. It’s available via the leak-sanitizer=on feature.</summary></entry><entry><title type="html">Marshall’s May Update</title><link href="http://cppalliance.org/marshall/2019/06/01/MarshallsJuneUpdate.html" rel="alternate" type="text/html" title="Marshall's May Update" /><published>2019-06-01T00:00:00+00:00</published><updated>2019-06-01T00:00:00+00:00</updated><id>http://cppalliance.org/marshall/2019/06/01/MarshallsJuneUpdate</id><content type="html" xml:base="http://cppalliance.org/marshall/2019/06/01/MarshallsJuneUpdate.html">&lt;p&gt;There are four main areas where I spend my time.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Libc++, where I am the “code owner”&lt;/li&gt;
  &lt;li&gt;WG21, where I am the chair of the Library Working Group (LWG)&lt;/li&gt;
  &lt;li&gt;Boost&lt;/li&gt;
  &lt;li&gt;Speaking at conferences&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;libc&quot;&gt;Libc++&lt;/h1&gt;

&lt;p&gt;The next big milestone for libc++ is the LLVM 9.0 release this summer. We’re working towards that, implementing new features and fixing bugs.&lt;/p&gt;

&lt;p&gt;As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day.&lt;/p&gt;

&lt;p&gt;This month was spent concentrating on code reviews and bug reports; so I implemented very little “new code”.&lt;/p&gt;

&lt;p&gt;There was a lot of “infrastructure work” done on libc++ this month; a large cleanup of the test suite (still in progress), a bunch of work on debug mode for the library (also still in progress)&lt;/p&gt;

&lt;h3 id=&quot;lwg-issues-resolved-this-month-in-libc&quot;&gt;LWG issues resolved this month in libc++&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wg21.link/lwg3204&quot;&gt;2960&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;sub_match::swap&lt;/code&gt; only swaps the base class&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-features-implemented-this-month-certainly-incomplete&quot;&gt;LLVM features implemented this month (certainly incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Improved the behavior of the compiler intrinsic &lt;code class=&quot;highlighter-rouge&quot;&gt;__is_base_of&lt;/code&gt;. Clang no longer generates an error when you ask about inheritance relationships with unions, even if the non-union class is incomplete. This intrinsic is used by libc++ to implement &lt;code class=&quot;highlighter-rouge&quot;&gt;std::is_base_of&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Fixed a few &lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt; bugs, and improved the &lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt; tests in C++03.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;llvm-bugs-resolved-this-month-probably-incomplete&quot;&gt;LLVM bugs resolved this month (probably incomplete)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR42037&quot;&gt;Bug 42037&lt;/a&gt; C++2a &lt;code class=&quot;highlighter-rouge&quot;&gt;std::midpoint&lt;/code&gt;`’s “Constraints” are not implemented&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://llvm.org/PR41876&quot;&gt;Bug 41876&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;std::hash&lt;/code&gt; should not accept &lt;code class=&quot;highlighter-rouge&quot;&gt;std::basic_strings&lt;/code&gt; with custom character traits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The current status of libc++ can be found here:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx2a_status.html&quot;&gt;C++20 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1z_status.html&quot;&gt;C++17 status&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libcxx.llvm.org/cxx1y_status.html&quot;&gt;C++14 status&lt;/a&gt; (Complete)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bugs.llvm.org/buglist.cgi?bug_status=__open__&amp;amp;product=libc%2B%2B&quot;&gt;Libc++ open bugs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;wg21&quot;&gt;WG21&lt;/h1&gt;

&lt;p&gt;There were no WG21 meetings in April. However, LWG held one teleconference this month, reviewing papers in advance of the July meeting.  We’ll have more teleconferences in June.&lt;/p&gt;

&lt;p&gt;I am working on more “cleanup” papers similar to &lt;a href=&quot;https://wg21.link/P1458&quot;&gt;P1458 - Mandating the Standard Library: Clause 16 - Language support library&lt;/a&gt;, and my &lt;a href=&quot;https://wg21.link/P0805&quot;&gt;P0805 - Comparing Containers&lt;/a&gt; needs an update.&lt;/p&gt;

&lt;p&gt;The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review.&lt;/p&gt;

&lt;p&gt;Also on my TODO list is to attempt to implement some of the proposals that are coming up for a vote in July (&lt;code class=&quot;highlighter-rouge&quot;&gt;flat_map&lt;/code&gt;, text formatting, etc).&lt;/p&gt;

&lt;h1 id=&quot;boost&quot;&gt;Boost&lt;/h1&gt;

&lt;p&gt;It’s been a quiet month for boost (except for C++ Now, the conference formerly known as BoostCon).&lt;/p&gt;

&lt;p&gt;There are a couple of good trip reports for C++Now:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://maddphysics.com/2019/05/13/cnow-2019-trip-report/&quot;&gt;Matthew Butler&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://thephd.github.io/c++now-2019-trip-report&quot;&gt;JeanHeyd Meneide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next &lt;a href=&quot;https://www.boost.org/development/index.html&quot;&gt;Boost release cycle&lt;/a&gt; is starting soon; with the deadline for new libraries coming up later this month. I’m hoping to mentor a new release manager with this release.&lt;/p&gt;

&lt;h1 id=&quot;conferences&quot;&gt;Conferences&lt;/h1&gt;

&lt;p&gt;Another travel month.  I spent a bunch of time away from home, but only one conference:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;At &lt;a href=&quot;http://www.cppnow.org&quot;&gt;C++ Now&lt;/a&gt; in Aspen, CO, I presented “The View from a C++ Standard Library Implementor”, which was voted the runner-up for “Most Engaging” talk.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have submitted a talk for &lt;a href=&quot;https://www.cppcon.com&quot;&gt;CppCon&lt;/a&gt; in September, but I will not hear back about this for a month or two.&lt;/p&gt;

&lt;p&gt;I have submitted talks for &lt;a href=&quot;https://cppconf-piter.ru/en/&quot;&gt;C++ Russia&lt;/a&gt; and &lt;a href=&quot;https://meetingcpp.com&quot;&gt;Meeting C++&lt;/a&gt;, which are both very close (timewise) to the Belfast WG21 meeting, but I haven’t heard back yet.&lt;/p&gt;

&lt;p&gt;I am looking forward to being at home for the entire month of June.&lt;/p&gt;</content><author><name></name></author><summary type="html">There are four main areas where I spend my time. Libc++, where I am the “code owner” WG21, where I am the chair of the Library Working Group (LWG) Boost Speaking at conferences Libc++ The next big milestone for libc++ is the LLVM 9.0 release this summer. We’re working towards that, implementing new features and fixing bugs. As the “code owner” for libc++, I also have to review the contributions of other people to libc++, and evaluate and fix bugs that are reported. That’s a never-ending task; there are new contributions ever day. This month was spent concentrating on code reviews and bug reports; so I implemented very little “new code”. There was a lot of “infrastructure work” done on libc++ this month; a large cleanup of the test suite (still in progress), a bunch of work on debug mode for the library (also still in progress) LWG issues resolved this month in libc++ 2960 sub_match::swap only swaps the base class LLVM features implemented this month (certainly incomplete) Improved the behavior of the compiler intrinsic __is_base_of. Clang no longer generates an error when you ask about inheritance relationships with unions, even if the non-union class is incomplete. This intrinsic is used by libc++ to implement std::is_base_of. Fixed a few regex bugs, and improved the regex tests in C++03. LLVM bugs resolved this month (probably incomplete) Bug 42037 C++2a std::midpoint`’s “Constraints” are not implemented Bug 41876 std::hash should not accept std::basic_strings with custom character traits The current status of libc++ can be found here: C++20 status C++17 status C++14 status (Complete) Libc++ open bugs WG21 There were no WG21 meetings in April. However, LWG held one teleconference this month, reviewing papers in advance of the July meeting. We’ll have more teleconferences in June. I am working on more “cleanup” papers similar to P1458 - Mandating the Standard Library: Clause 16 - Language support library, and my P0805 - Comparing Containers needs an update. The goal of the July meeting is to have a “Committee Draft” (CD) of the proposed C++20 standard that can be sent out for review. Also on my TODO list is to attempt to implement some of the proposals that are coming up for a vote in July (flat_map, text formatting, etc). Boost It’s been a quiet month for boost (except for C++ Now, the conference formerly known as BoostCon). There are a couple of good trip reports for C++Now: Matthew Butler JeanHeyd Meneide The next Boost release cycle is starting soon; with the deadline for new libraries coming up later this month. I’m hoping to mentor a new release manager with this release. Conferences Another travel month. I spent a bunch of time away from home, but only one conference: At C++ Now in Aspen, CO, I presented “The View from a C++ Standard Library Implementor”, which was voted the runner-up for “Most Engaging” talk. I have submitted a talk for CppCon in September, but I will not hear back about this for a month or two. I have submitted talks for C++ Russia and Meeting C++, which are both very close (timewise) to the Belfast WG21 meeting, but I haven’t heard back yet. I am looking forward to being at home for the entire month of June.</summary></entry><entry><title type="html">Damian’s April Update</title><link href="http://cppalliance.org/company,/damian/2019/05/05/DamiansMayUpdate.html" rel="alternate" type="text/html" title="Damian's April Update" /><published>2019-05-05T00:00:00+00:00</published><updated>2019-05-05T00:00:00+00:00</updated><id>http://cppalliance.org/company,/damian/2019/05/05/DamiansMayUpdate</id><content type="html" xml:base="http://cppalliance.org/company,/damian/2019/05/05/DamiansMayUpdate.html">&lt;p&gt;This month I’ve been working on the following projects:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Certify&lt;/li&gt;
  &lt;li&gt;Boost.Beast&lt;/li&gt;
  &lt;li&gt;Boost.Build&lt;/li&gt;
  &lt;li&gt;BeastLounge&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;certify&quot;&gt;Certify&lt;/h1&gt;
&lt;p&gt;Certify did not have any platform-independent means of caching certificate
status (i.e. revoked, valid, unknown), so I implemented one. For now it has to
be manually filled, but I’ll add a way to import a static blacklist (somewhat
similar to the builtin blacklist in Chrome) and query the status of a
certificate. Unfortunately there is no way to handle OCSP stapling within the
verification callback invoked by OpenSSL which is quite detrimental to
usability. Additionally, OpenSSL doesn’t have a way of starting and waiting for
an asynchronous operation within callbacks (without blocking).&lt;/p&gt;

&lt;p&gt;Don’t forget to star the repository: &lt;a href=&quot;https://github.com/djarek/certify&quot;&gt;https://github.com/djarek/certify&lt;/a&gt;!&lt;/p&gt;

&lt;h1 id=&quot;boostbeast&quot;&gt;Boost.Beast&lt;/h1&gt;
&lt;p&gt;When working on making sure Beast is &lt;code class=&quot;highlighter-rouge&quot;&gt;std::launder&lt;/code&gt;-correct, I ran into a number
of previously undiagnosed bugs in Beast. All of them have been fixed in
&lt;a href=&quot;https://github.com/boostorg/beast/pull/1598/files&quot;&gt;v254&lt;/a&gt;. I was quite confused
why these issues weren’t found by CI previously. I’ve been able to track it down
to old toolchain versions in Travis. Additionally, the test matrix lacks a few
fairly important variants. Considering the fact that Trusty is no longer
supported and the switch to Xenial is inevitable, I’ve decided to port over the
CI to Azure Pipelines, because it offers better concurrency which allows the
Beast CI to afford a larger test matrix. In the process I’ve also decided to use
as many default b2 options as possible, to make future changes to the CI easier.
There’s still an issue with Valgrind in Xenial to be resolved (doesn’t support
the &lt;code class=&quot;highlighter-rouge&quot;&gt;RDRAND&lt;/code&gt; instruction).&lt;/p&gt;

&lt;h1 id=&quot;boostbuild&quot;&gt;Boost.Build&lt;/h1&gt;
&lt;p&gt;While working on the AzP CI for Beast, I found out that the &lt;code class=&quot;highlighter-rouge&quot;&gt;coverage&lt;/code&gt; feature
in &lt;code class=&quot;highlighter-rouge&quot;&gt;b2&lt;/code&gt; doesn’t actually set build flags. &lt;code class=&quot;highlighter-rouge&quot;&gt;coverage=all&lt;/code&gt; will now properly cause
tests to produce &lt;code class=&quot;highlighter-rouge&quot;&gt;gcno&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;gcda&lt;/code&gt; files for consumption by the lcov tool.&lt;/p&gt;

&lt;h1 id=&quot;beastlounge&quot;&gt;BeastLounge&lt;/h1&gt;
&lt;p&gt;When experimenting with the BeastLounge application running on Heroku I found
out that Heroku’s router has a builtin 55s timeout which dropped websocket
connections. I solved the issue by making the websocket ping timeouts
configurable.&lt;/p&gt;</content><author><name></name></author><summary type="html">This month I’ve been working on the following projects: Certify Boost.Beast Boost.Build BeastLounge Certify Certify did not have any platform-independent means of caching certificate status (i.e. revoked, valid, unknown), so I implemented one. For now it has to be manually filled, but I’ll add a way to import a static blacklist (somewhat similar to the builtin blacklist in Chrome) and query the status of a certificate. Unfortunately there is no way to handle OCSP stapling within the verification callback invoked by OpenSSL which is quite detrimental to usability. Additionally, OpenSSL doesn’t have a way of starting and waiting for an asynchronous operation within callbacks (without blocking). Don’t forget to star the repository: https://github.com/djarek/certify! Boost.Beast When working on making sure Beast is std::launder-correct, I ran into a number of previously undiagnosed bugs in Beast. All of them have been fixed in v254. I was quite confused why these issues weren’t found by CI previously. I’ve been able to track it down to old toolchain versions in Travis. Additionally, the test matrix lacks a few fairly important variants. Considering the fact that Trusty is no longer supported and the switch to Xenial is inevitable, I’ve decided to port over the CI to Azure Pipelines, because it offers better concurrency which allows the Beast CI to afford a larger test matrix. In the process I’ve also decided to use as many default b2 options as possible, to make future changes to the CI easier. There’s still an issue with Valgrind in Xenial to be resolved (doesn’t support the RDRAND instruction). Boost.Build While working on the AzP CI for Beast, I found out that the coverage feature in b2 doesn’t actually set build flags. coverage=all will now properly cause tests to produce gcno and gcda files for consumption by the lcov tool. BeastLounge When experimenting with the BeastLounge application running on Heroku I found out that Heroku’s router has a builtin 55s timeout which dropped websocket connections. I solved the issue by making the websocket ping timeouts configurable.</summary></entry></feed>